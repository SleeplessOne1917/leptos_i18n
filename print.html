<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="02_getting_started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="setting_up/index.html"><strong aria-hidden="true">3.</strong> Setting Up</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setting_up/01_configuration.html"><strong aria-hidden="true">3.1.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="setting_up/02_file_structure.html"><strong aria-hidden="true">3.2.</strong> File structure</a></li><li class="chapter-item expanded "><a href="setting_up/03_namespaces.html"><strong aria-hidden="true">3.3.</strong> Namespaces</a></li></ol></li><li class="chapter-item expanded "><a href="declare/index.html"><strong aria-hidden="true">4.</strong> Declare Translations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="declare/01_key_value.html"><strong aria-hidden="true">4.1.</strong> Key-Value Pairs</a></li><li class="chapter-item expanded "><a href="declare/02_interpolation.html"><strong aria-hidden="true">4.2.</strong> Interpolation</a></li><li class="chapter-item expanded "><a href="declare/03_plurals.html"><strong aria-hidden="true">4.3.</strong> Plurals</a></li><li class="chapter-item expanded "><a href="declare/04_subkeys.html"><strong aria-hidden="true">4.4.</strong> Subkeys</a></li><li class="chapter-item expanded "><a href="declare/05_foreign_keys.html"><strong aria-hidden="true">4.5.</strong> Foreign keys</a></li><li class="chapter-item expanded "><a href="declare/06_mix_kinds.html"><strong aria-hidden="true">4.6.</strong> Mixing Kinds</a></li></ol></li><li class="chapter-item expanded "><a href="usage/index.html"><strong aria-hidden="true">5.</strong> Use Translations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/01_load.html"><strong aria-hidden="true">5.1.</strong> Load The Translations</a></li><li class="chapter-item expanded "><a href="usage/02_context.html"><strong aria-hidden="true">5.2.</strong> I18nContext</a></li><li class="chapter-item expanded "><a href="usage/03_t_macro.html"><strong aria-hidden="true">5.3.</strong> t! Macro</a></li><li class="chapter-item expanded "><a href="usage/04_td_macro.html"><strong aria-hidden="true">5.4.</strong> td! Macro</a></li><li class="chapter-item expanded "><a href="usage/05_td_string_macro.html"><strong aria-hidden="true">5.5.</strong> td_string! Macro</a></li></ol></li><li class="chapter-item expanded "><a href="06_features.html"><strong aria-hidden="true">6.</strong> Features</a></li><li class="chapter-item expanded "><a href="appendix_i18n_ally.html"><strong aria-hidden="true">7.</strong> Appendix: i18n Ally extension for VSC</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This book is intended as an introduction to the <a href="https://github.com/Baptistemontan/leptos_i18n">Leptos_i18n</a> crate.</p>
<p>This crate is made to simplify Internationalization in a <a href="https://crates.io/crates/leptos">Leptos</a> application, that loads locales at <strong><em>compile time</em></strong> and provides compile time checks for translation keys, interpolation keys and the selected locale.</p>
<p>This guide does assume you know some basics about <code>Leptos</code>, but the majority of the guide is about declaring the translations and how to use them, you can find the <code>Leptos</code> book <a href="https://leptos-rs.github.io/leptos/">here</a>.</p>
<p>You can find more detailed docs for each part of the API at <a href="https://docs.rs/leptos_i18n/latest/leptos_i18n/">Docs.rs</a>.</p>
<blockquote>
<p>The source code for the book is available <a href="https://github.com/Baptistemontan/leptos_i18n/tree/main/docs/book">here</a>. PRs for typos or clarification are always welcome.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>First thing we need is a <code>Leptos</code> project, you can find documentation on how to set one up in the <code>Leptos</code> <a href="https://leptos-rs.github.io/leptos/02_getting_started.html">book</a>.</p>
<p>Once you have set one up, you can add this crate to your project with</p>
<pre><code class="language-bash">cargo add leptos_i18n
</code></pre>
<h2 id="actix-web-backend"><a class="header" href="#actix-web-backend"><code>actix-web</code> Backend</a></h2>
<p>When compiling for the backend using <code>actix-web</code>, enable the <code>actix</code> feature:</p>
<pre><code class="language-toml"># Cargo.toml

[features]
ssr = [
    &quot;leptos_i18n/actix&quot;,
]
</code></pre>
<p>You can see an example using <code>actix-web</code> <a href="https://github.com/Baptistemontan/leptos_i18n/tree/master/examples/hello_world_actix">here</a></p>
<h2 id="axum-backend"><a class="header" href="#axum-backend"><code>axum</code> Backend</a></h2>
<p>When compiling for the backend using <code>axum</code>, enable the <code>axum</code> feature:</p>
<pre><code class="language-toml"># Cargo.toml

[features]
ssr = [
    &quot;leptos_i18n/axum&quot;,
]
</code></pre>
<p>You can see an example using <code>axum</code> <a href="https://github.com/Baptistemontan/leptos_i18n/tree/master/examples/hello_world_axum">here</a></p>
<h2 id="hydrate"><a class="header" href="#hydrate">Hydrate</a></h2>
<p>When compiling for the client, enable the <code>hydrate</code> feature:</p>
<pre><code class="language-toml"># Cargo.toml

[features]
hydrate = [
    &quot;leptos_i18n/hydrate&quot;,
]
</code></pre>
<p>There exist 3 examples using hydratation:</p>
<ul>
<li><a href="https://github.com/Baptistemontan/leptos_i18n/tree/master/examples/hello_world_actix">Hello World Actix</a></li>
<li><a href="https://github.com/Baptistemontan/leptos_i18n/tree/master/examples/hello_world_axum">Hello World Axum</a></li>
<li><a href="https://github.com/Baptistemontan/leptos_i18n/tree/master/examples/workspace">Using Workspace</a></li>
</ul>
<h2 id="client-side-rendering"><a class="header" href="#client-side-rendering">Client Side Rendering</a></h2>
<p>When compiling for the client, enable the <code>csr</code> feature:</p>
<pre><code class="language-toml"># Cargo.toml

[dependencies.leptos_i18n]
features = [&quot;csr&quot;]
</code></pre>
<p>You can find an example using CSR <a href="https://github.com/Baptistemontan/leptos_i18n/tree/master/examples/csr">here</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up"><a class="header" href="#setting-up">Setting Up</a></h1>
<p>This first section will introduce you to the configurations you need to use <code>leptos_i18n</code>. By the end of this section, you should be able to
set up the basics to start using translations in your <code>Leptos</code> application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>This crate in basically entirely based around one macro: the <code>load_locales!</code> macro. We will cover it in a later chapter, but for now just know that it looks at your translation files and generates code for them.</p>
<p>To load those translations it first needs to know what to look for, so you need to declare what locales you are supporting and which one is the default.
To do that you use the <code>[package.metadata.leptos-i18n]</code> section in your <code>Cargo.toml</code>.</p>
<p>To declare <code>en</code> and <code>fr</code> as locales, with <code>en</code> being the default you would write:</p>
<pre><code class="language-toml">[package.metadata.leptos-i18n]
default = &quot;en&quot;
locales = [&quot;en&quot;, &quot;fr&quot;]
</code></pre>
<p>There is 2 more optional values you can supply:</p>
<ul>
<li><code>namespaces</code>: This is to split your translations in multiple files, we will cover it in a later chapter</li>
<li><code>locales-dir</code>: This is to have a custom path to the directory containing the locales files, it default to <code>&quot;./locales&quot;</code>.</li>
</ul>
<p>Once this configuration is done, you can start writing your translations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h1>
<p>Now that you have configured your locales, you can start writing your translations, this chapter covers where to put your files. We will cover how to write them in another section.</p>
<p>By default you must put your files in the <code>./locales</code> directory, and each file must be <code>%{locale}.json</code>:</p>
<pre><code class="language-bash">./locales
├── en.json
└── fr.json
</code></pre>
<h2 id="custom-directory"><a class="header" href="#custom-directory">Custom Directory</a></h2>
<p>You can change the path to the directory containing the files with the <code>locales-dir</code> field in the configuration, for example</p>
<pre><code class="language-toml">[package.metadata.leptos-i18n]
default = &quot;en&quot;
locales = [&quot;en&quot;, &quot;fr&quot;]
locales-dir = &quot;./path/to/mylocales
</code></pre>
<p>will look for</p>
<pre><code class="language-bash">./path
└── to
    └── mylocales
        ├── en.json
        └── fr.json
</code></pre>
<h2 id="other-formats"><a class="header" href="#other-formats">Other Formats</a></h2>
<p>JSON being the default, you can change that by first removing the defaults features, and enabling the feature for the format you need:</p>
<pre><code class="language-toml"># Cargo.toml

[dependencies]
leptos_i18n = {
    default-features = false,
    features = [&quot;yaml_files&quot;] # other default features: [&quot;cookie&quot;]
}
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Format</th><th>Feature</th></tr></thead><tbody>
<tr><td>JSON (default)</td><td><code>json_files</code></td></tr>
<tr><td>YAML</td><td><code>yaml_files</code></td></tr>
</tbody></table>
</div>
<p>Other formats may be supported later.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<p>Translations files can grow quite rapidly and becomes very big, and avoiding key collisions can be hard without avoiding long names.
To avoid this situation you can declare namespaces in the configuration:</p>
<pre><code class="language-toml">[package.metadata.leptos-i18n]
default = &quot;en&quot;
locales = [&quot;en&quot;, &quot;fr&quot;]
namespaces = [&quot;common&quot;, &quot;home&quot;]
</code></pre>
<p>Then your file structures must look like this in the <code>/locales</code> directory:</p>
<pre><code class="language-bash">./locales
├── en
│   ├── common.json
│   └── home.json
└── fr
    ├── common.json
    └── home.json
</code></pre>
<p>You can now make smaller files, with one for each sections of the website for example.
This also allow the <code>common</code> namespace to use keys that the <code>home</code> namespace also use, without colliding.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="declare-translations"><a class="header" href="#declare-translations">Declare translations</a></h1>
<p>Now that we covered the configuration and where to put each file, we can now start writing the translations.
This chapter cove this topic only for the <code>JSON</code> format.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-value-pairs"><a class="header" href="#key-value-pairs">Key-Value Pairs</a></h1>
<p>As expected, you declare your translations a key-value pairs:</p>
<pre><code class="language-json">{
  &quot;hello_world&quot;: &quot;Hello World!&quot;
}
</code></pre>
<p>But there are additional rules you must follow in addition to those of the format you use.</p>
<h2 id="keys"><a class="header" href="#keys">Keys</a></h2>
<p>Key names must be <a href="https://doc.rust-lang.org/reference/identifiers.html">valid Rust identifier</a>, with the exception of <code>-</code> that would be converted to <code>_</code>.</p>
<h2 id="same-keys-across-files"><a class="header" href="#same-keys-across-files">Same keys across files</a></h2>
<p>The keys must be the same across all files, else the <code>load_locales!</code> macro will emit warnings. The difference in keys is based on the default locale.</p>
<h3 id="missing-key"><a class="header" href="#missing-key">Missing key</a></h3>
<p>If a key is present in the default locale but not in another locale, the other locale will default it's value to the default locale one and emit a warning that a key is missing in that locale.</p>
<p>If you want to explicitly state that this value take the value of the default locale, you can declare it as <code>null</code>:</p>
<pre><code class="language-json">{
  &quot;take_value_of_default&quot;: null
}
</code></pre>
<p>This will no longer trigger a warning for that key.</p>
<h3 id="surplus-key"><a class="header" href="#surplus-key">Surplus key</a></h3>
<p>If a key is present in another locale but not in the default locale, this key will be ignored and a warning will be emitted.</p>
<h2 id="value-kinds"><a class="header" href="#value-kinds">Value Kinds</a></h2>
<p>You can specify multiple kinds of values:</p>
<ul>
<li>String</li>
<li>Interpolated String</li>
<li>Plurals</li>
</ul>
<p>The next chapters of this section will cover them, apart for strings, those are self explanatory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interpolation"><a class="header" href="#interpolation">Interpolation</a></h1>
<h2 id="interpolate-values"><a class="header" href="#interpolate-values">Interpolate Values</a></h2>
<p>There may be situations where you must interpolate a value inside your translations, for example a dynamic number.
You could declare 2 translations and use them around that number, but this is not an elegant solution.</p>
<p>To declare a value that will be interpolated in your translations, simply give it a name around <code>{{ }}</code>:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: &quot;You clicked {{ count }} times&quot;
}
</code></pre>
<h2 id="interpolate-components"><a class="header" href="#interpolate-components">Interpolate Components</a></h2>
<p>There may also be situations where you want to use wrap a part of your translation into a component, for example to highlight it.</p>
<p>You can declare a component with html-like syntax:</p>
<pre><code class="language-json">{
  &quot;highlight_me&quot;: &quot;highlight &lt;b&gt;me&lt;/b&gt;&quot;
}
</code></pre>
<h2 id="use-both"><a class="header" href="#use-both">Use both</a></h2>
<p>You can mix them both without problem:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: &quot;You clicked &lt;b&gt;{{ count }}&lt;/b&gt; times&quot;
}
</code></pre>
<h2 id="names"><a class="header" href="#names">Names</a></h2>
<p>Just like keys, names of variable/components can be anything as long as it is a valid Rust identifier, apart from <code>-</code> which will be converted to <code>_</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plurals"><a class="header" href="#plurals">Plurals</a></h1>
<p>What if your translation display a count, and thus you must handle the case where the count is zero, one, or multiple ? You could declare multiple translations and use some kind of switch-case, but again this is not elegant.</p>
<p>To simplify this process you can declare plurals, they are based around a count and display different translations based on this count.</p>
<p>To declare them the key takes a sequence where each element is a sequence with the first element being the value, and the other element the count to match against:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;You have not clicked yet&quot;, 0],
    [&quot;You clicked once&quot;, 1],
    [&quot;You clicked {{ count }} times&quot;, &quot;_&quot;]
  ]
}
</code></pre>
<h2 id="multiple-exact-values"><a class="header" href="#multiple-exact-values">Multiple exact values</a></h2>
<p>You can declare multiple counts to match against:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;0 or 5&quot;, 0, 5],
    [&quot;1, 2, 3 or 4&quot;, 1, 2, 3, 4],
    [&quot;You clicked {{ count }} times&quot;, &quot;_&quot;]
  ]
}
</code></pre>
<h2 id="ranges"><a class="header" href="#ranges">Ranges</a></h2>
<p>You can also declare a range where the translations is used:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;0 or 5&quot;, 0, 5],
    [&quot;1, 2, 3 or 4&quot;, &quot;1..=4&quot;],
    [&quot;You clicked {{ count }} times&quot;, &quot;_&quot;]
  ]
}
</code></pre>
<p>You can use all Rust ranges syntax: <code>s..e</code>, <code>..e</code>, <code>s..</code>, <code>s..=e</code>, <code>..=e</code> or even <code>..</code> ( <code>..</code> will be considered fallback <code>_</code>)</p>
<h2 id="number-type"><a class="header" href="#number-type">Number type</a></h2>
<p>By default the count is expected to be an <code>i32</code>, but you can change that by specifying the type as the first element of the sequence:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    &quot;u32&quot;,
    [&quot;You have not clicked yet&quot;, 0],
    [&quot;You clicked once&quot;, 1],
    [&quot;You clicked {{ count }} times&quot;, &quot;_&quot;]
  ]
}
</code></pre>
<p>Now you only have to cover the <code>u32</code> range.</p>
<p>The supported types are <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>f32</code> and <code>f64</code>.</p>
<h2 id="fallback"><a class="header" href="#fallback">Fallback</a></h2>
<p>If all the given counts don't fill the range of the number type, you can use a fallback (<code>&quot;_&quot;</code> or <code>&quot;..&quot;</code>) as seen above, but it can be completely omitted on the last element of the sequence:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;You have not clicked yet&quot;, 0],
    [&quot;You clicked once&quot;, 1],
    [&quot;You clicked {{ count }} times&quot;]
  ]
}
</code></pre>
<p>Fallbacks are not required if you already cover the full number range:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    &quot;u8&quot;,
    [&quot;You have not clicked yet&quot;, 0],
    [&quot;1 to 254&quot;, &quot;1..=254&quot;],
    [&quot;255&quot;, 255]
  ]
}
</code></pre>
<p>Fallbacks are always required for <code>f32</code> and <code>f64</code>.</p>
<h2 id="order"><a class="header" href="#order">Order</a></h2>
<p>The order of the plurals matter, for example:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;first&quot;, &quot;0..5&quot;],
    [&quot;second&quot;, &quot;0..=5&quot;],
    [&quot;You clicked {{ count }} times&quot;]
  ]
}
</code></pre>
<p>Here &quot;second&quot; will only be printed if count is 5, if <code>0 &lt;= count &lt; 5</code> then &quot;first&quot; will be printed.</p>
<h2 id="mix-ranges-with-exact-values"><a class="header" href="#mix-ranges-with-exact-values">Mix ranges with exact values</a></h2>
<p>You can totally mix them, this is valid:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;first&quot;, 0, &quot;3..5&quot;, &quot;10..=56&quot;],
    [&quot;second&quot;, &quot;0..3&quot;, &quot;..78&quot;],
    [&quot;You clicked {{ count }} times&quot;]
  ]
}
</code></pre>
<h2 id="use-interpolation"><a class="header" href="#use-interpolation">Use interpolation</a></h2>
<p>The &quot;You clicked {{ count }} times&quot; kind of gave it away, but you can use interpolation in your plurals, this is valid:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: [
    [&quot;&lt;b&gt;first&lt;/b&gt;&quot;, 0, &quot;3..5&quot;, &quot;10..=56&quot;],
    [&quot;&lt;i&gt;second&lt;/i&gt;&quot;, &quot;0..3&quot;, &quot;..78&quot;],
    [&quot;You clicked {{ count }} times and have {{ banana_count }} bananas&quot;]
  ]
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subkeys"><a class="header" href="#subkeys">Subkeys</a></h1>
<p>You can declare subkeys by just giving a map to the key:</p>
<pre><code class="language-json">{
  &quot;subkeys&quot;: {
    &quot;subkey_1&quot;: &quot;This is subkey_1&quot;,
    &quot;subkey_n&quot;: &quot;This is subkey &lt;b&gt;{{ n }}&lt;/b&gt;&quot;,
    &quot;nested_subkeys&quot;: {
      &quot;nested_subkey_1&quot;: &quot;you can nest subkeys&quot;
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foreign-keys"><a class="header" href="#foreign-keys">Foreign keys</a></h1>
<p>Foreign keys let you re-use already declared translations, you declare them like variables but with a '@' before the path:</p>
<pre><code class="language-json">{
  &quot;hello_world&quot;: &quot;Hello World!&quot;,
  &quot;reuse&quot;: &quot;message: {{ @hello_world }}&quot;
}
</code></pre>
<p>This will replace <code>{{ @hello_world }}</code> by the value of the key <code>hello_world</code>, making <code>reuse</code> equal to <code>&quot;message: Hello World!&quot;</code>.</p>
<p>You can point to any key other than plurals and keys containing subkeys.</p>
<p>To point to subkeys you give the path by separating the the key by <code>.</code>: <code>{{ @key.subkey.subsubkey }}</code>.</p>
<p>When using namespaces you <em>must</em> specify the namespace of the key you are looking for, using <code>::</code>: <code>{{ @namespace::key }}</code>.</p>
<p>You can point to explicitly defaulted keys, but not implicitly defaulted ones.</p>
<h2 id="supply-arguments"><a class="header" href="#supply-arguments">Supply arguments</a></h2>
<p>You can also supply arguments to fill variables of the pointed key:</p>
<pre><code class="language-json">{
  &quot;click_count&quot;: &quot;You clicked {{ count }} times&quot;,
  &quot;clicked_twice&quot;: &quot;{{ @click_count, count = 'two' }}&quot;
}
</code></pre>
<p>This will result to <code>clicked_twice</code> to have the value <code>&quot;You clicked two times&quot;</code>.</p>
<p>Arguments must be string, delimited by either single quotes or double quotes.</p>
<p><strong>Note</strong>: Any argument with no matching variable are just discarded, they will not emit any warning/error.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mixing-kinds"><a class="header" href="#mixing-kinds">Mixing Kinds</a></h1>
<p>What happens if for a key you declare plurals in one locale, interpolation in another, and a simple string in a third ?</p>
<p>Well this is totally allowed, but you will still need to supply all values/components of every locale combined when using the translation, regardless of what the current locale is.</p>
<p>What is not allowed to mix are subkeys. If a key has subkeys in one locale, the key must have subkeys in all locales.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-use-in-code"><a class="header" href="#how-to-use-in-code">How to use in code</a></h1>
<p>Now that we know how to declare our translations, we can incorporate them in the code, and this is what this chapter cover.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="load-the-translations"><a class="header" href="#load-the-translations">Load The Translations</a></h1>
<p>Loading all those translations is the role of the <code>load_locales!</code> macro, just call this macro anywhere in your codebase and it will generate the code needed to use your translations.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lib.rs/main.rs

leptos_i18n::load_locales!();
<span class="boring">}</span></code></pre></pre>
<h2 id="the-i18n-module"><a class="header" href="#the-i18n-module">The <code>i18n</code> module</a></h2>
<p>The macro will generate a module called <code>i18n</code>, this module contain everything you need you use your translations.</p>
<h3 id="the-locale-enum"><a class="header" href="#the-locale-enum">The <code>Locale</code> enum</a></h3>
<p>You can find the enum <code>Locale</code> in this module, it represent all the locales you declared, for example this configuration:</p>
<pre><code class="language-toml">[package.metadata.leptos-i18n]
default = &quot;en&quot;
locales = [&quot;en&quot;, &quot;fr&quot;]
</code></pre>
<p>Generate this enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]
#[allow(non_camel_case_types)]
pub enum Locale {
    en,
    fr
}

impl Default for Locale {
    fn default() -&gt; Self {
        Locale::en
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-i18nkeys-struct"><a class="header" href="#the-i18nkeys-struct">The <code>I18nKeys</code> struct</a></h3>
<p>This generated struct represent the structure of your translations, with each translation key being a key in this struct.</p>
<p>It contain an associated constant for each locale, where every field is populated with the values for the locale.</p>
<p><code>en.json</code></p>
<pre><code class="language-json">{
  &quot;hello_world&quot;: &quot;Hello World!&quot;
}
</code></pre>
<p><code>fr.json</code></p>
<pre><code class="language-json">{
  &quot;hello_world&quot;: &quot;Bonjour le Monde!&quot;
}
</code></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>leptos_i18n::load_locales!();

assert_eq!(i18n::I18nKeys::en.hello_world, &quot;Hello World!&quot;);
assert_eq!(i18n::I18nKeys::fr.hello_world, &quot;Bonjour le Monde!&quot;);
<span class="boring">}</span></code></pre></pre>
<p>This way of accessing the values is possible but it's not practical and most importantly not reactive, we will cover in a later section the tool this crate give you to simplify it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i18ncontext"><a class="header" href="#i18ncontext"><code>I18nContext</code></a></h1>
<p>The <code>I18nContext</code> type is here to make all your application reactive to the change of the locale, you will use it to access the current locale or change it.</p>
<p>The context is a wrapper around a <code>RwSignal</code> of the current locale, every getter/setter must be used with the same reasoning as signals.</p>
<h2 id="provide-the-context"><a class="header" href="#provide-the-context">Provide the context</a></h2>
<p>The <code>load_locales!</code> macro generates the <code>provide_i18n_context</code> function in the <code>i18n</code> module,
you can use this function in a component to make the context accessible to all child components.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

// root of the application
#[component]
pub fn App() -&gt; impl IntoView {
    provide_i18n_context();

    view! {
        /* */
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="access-the-context"><a class="header" href="#access-the-context">Access the context</a></h2>
<p>Once provided, you can access it with the <code>use_i18n</code> function, also generated in the <code>i18n</code> module.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

// somewhere else in the application
#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    view! {
        /* */
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="access-the-current-locale"><a class="header" href="#access-the-current-locale">Access the current locale</a></h2>
<p>With the context you can access the current locale with the <code>get_locale</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    create_effect(|_| {
        let locale = i18n.get_locale();

        match locale {
            Locale::en =&gt; {
                log!(&quot;locale en&quot;);
            },
            Locale::fr =&gt; {
                log!(&quot;locale fr&quot;);
            }
        }
    })

    view! {
        /* */
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If you enable the <code>nightly</code> feature you can directly call the context: <code>let locale = i18n();</code>.</p>
<p>A non-reactive counterpart to <code>get_locale</code> exist: <code>get_locale_untracked</code>.</p>
<h2 id="change-the-locale"><a class="header" href="#change-the-locale">Change the locale</a></h2>
<p>With the context you can change the current locale with the <code>set_locale</code> method, for example this component will switch between <code>en</code> and <code>fr</code> with a button:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    let on_switch = move |_| {
        let new_locale = match i18n.get_locale() {
            Locale::en =&gt; Locale::fr,
            Locale::fr =&gt; Locale::en,
        };
        i18n.set_locale(new_locale);
    };

    view! {
        &lt;button on:click=on_switch&gt;{t!(i18n, click_to_change_lang)}&lt;/button&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If you enable the <code>nightly</code> feature you can directly call the context<code>i18n(new_locale);</code>.</p>
<p>A non-reactive counterpart to <code>set_locale</code> exist: <code>set_locale_untracked</code>.</p>
<h2 id="note-on-island"><a class="header" href="#note-on-island">Note on island</a></h2>
<p>If you use the <code>experimental-islands</code> feature from Leptos this will not work and cause an error on the client:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]
fn App() -&gt; impl IntoView {
    provide_i18n_context();

    view! {
        &lt;HomePage /&gt;
    }
}

#[island]
fn HomePage() -&gt; impl IntoView {
    let i18n = use_i18n();
    view! {
        &lt;p&gt;{t!(i18n, hello_world)}&lt;/p&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Because <code>App</code> is only rendered on the server, and the code is never called on the client, thus the context is never provided on the client, making <code>use_i18n</code> panic when trying to access it.</p>
<p>To fix it first enable the <code>experimental-islands</code> feature for <code>leptos_i18n</code> and use the <code>I18nContextProvider</code> component exported by the <code>i18n</code> module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]
fn App() -&gt; impl IntoView {
    view! {
        &lt;I18nContextProvider&gt;
            &lt;HomePage /&gt;
        &lt;/I18nContextProvider&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-t-macro"><a class="header" href="#the-t-macro">The <code>t!</code> Macro</a></h1>
<p>To access your translations the <code>t!</code> macro is used, you can access a string with a simple <code>t!(i18n, $key)</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    view! {
        {/* &quot;hello_world&quot;: &quot;Hello World!&quot; */}
        &lt;p&gt;{t!(i18n, hello_world)}&lt;/p&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interpolate-values-1"><a class="header" href="#interpolate-values-1">Interpolate Values</a></h2>
<p>If some variables are declared for this key, you can pass them like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    let (counter, _set_counter) = create_signal(0);

    view! {
        {/* &quot;click_count&quot;: &quot;you clicked {{ count }} times&quot; */}
        &lt;p&gt;{t!(i18n, click_count, count = move || counter.get())}&lt;/p&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If your variable has the same name as the value, you can pass it directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    let (counter, _set_counter) = create_signal(0);

    let count = move || counter.get();

    view! {
        {/* &quot;click_count&quot;: &quot;you clicked {{ count }} times&quot; */}
        &lt;p&gt;{t!(i18n, click_count, count)}&lt;/p&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You can pass anything that implement <code>IntoView + Clone + 'static</code>, you can pass a view if you want:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    let (counter, _set_counter) = create_signal(0);

    let count = view!{
        &lt;b&gt;
            { move || counter.get() }
        &lt;/b&gt;
    };

    view! {
        {/* &quot;click_count&quot;: &quot;you clicked {{ count }} times&quot; */}
        &lt;p&gt;{t!(i18n, click_count, count)}&lt;/p&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Any missing values will generate an error.</p>
<h2 id="interpolate-components-1"><a class="header" href="#interpolate-components-1">Interpolate components</a></h2>
<p>If some components are declared for this key, you can pass them like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    let (counter, _set_counter) = create_signal(0);
    let count = move || counter.get();

    view! {
        {/* &quot;click_count&quot;: &quot;you clicked &lt;b&gt;{{ count }}&lt;/b&gt; times&quot; */}
        &lt;p&gt;{t!(i18n, click_count, count, &lt;b&gt; = |children| view!{ &lt;b&gt;{children}&lt;/b&gt; })}&lt;/p&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If your variable as the same name as the component, you can pass it directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    let (counter, _set_counter) = create_signal(0);
    let count = move || counter.get();

    let b = |children| view!{ &lt;b&gt;{children}&lt;/b&gt; };

    view! {
        {/* &quot;click_count&quot;: &quot;you clicked &lt;b&gt;{{ count }}&lt;/b&gt; times&quot; */}
        &lt;p&gt;{t!(i18n, click_count, count, &lt;b&gt;)}&lt;/p&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You can pass anything that implement <code>Fn(leptos::ChildrenFn) -&gt; V + Clone + 'static</code> where <code>V: IntoView</code>.</p>
<p>Any missing components will generate an error.</p>
<p><code>|children| view! { &lt;b&gt;{children}&lt;/b&gt; }</code> can be verbose for simple components, you can use this syntax when the children is wrapped by a single component:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// key = &quot;&lt;b&gt;{{ count }}&lt;/b&gt;&quot;
t!(i18n, key, &lt;b&gt; = &lt;span /&gt;, count = 32);
<span class="boring">}</span></code></pre></pre>
<p>This will render <code>&lt;span&gt;32&lt;/span&gt;</code>.</p>
<p>You can set attributes, event handlers, props ect:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>t!(i18n, key, &lt;b&gt; = &lt;span attr:id=&quot;my_id&quot; on:click=|_| { /* do stuff */} /&gt;, count = 0);
<span class="boring">}</span></code></pre></pre>
<p>Basically <code>&lt;name .../&gt;</code> expand to <code>move |children| view! { &lt;name ...&gt;{children}&lt;/name&gt; }</code></p>
<h2 id="plurals-1"><a class="header" href="#plurals-1">Plurals</a></h2>
<p>Plurals expect a variable named <code>count</code>, that implement <code>Fn() -&gt; N + Clone + 'static</code> where <code>N</code> is the specified type of the plural (default is <code>i32</code>).</p>
<h2 id="access-subkeys"><a class="header" href="#access-subkeys">Access subkeys</a></h2>
<p>You can access subkeys by simply separating the path with <code>.</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    view! {
        {/*
            &quot;subkeys&quot;: {
                &quot;subkey_1&quot;: &quot;This is subkeys.subkey_1&quot;
            }
        */}
        &lt;p&gt;{t!(i18n, subkeys.subkey_1)}&lt;/p&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="access-namespaces"><a class="header" href="#access-namespaces">Access namespaces</a></h2>
<p>Namespaces are implemented as subkeys, you first access the namespace then the keys in that namespace:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    view! {
        &lt;p&gt;{t!(i18n, my_namespace.hello_world)}&lt;/p&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To avoid confusion with subkeys you can use <code>::</code> to separate the namespace name from the rest of the path:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>t!(i18n, my_namespace::hello_world)
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-td-macro"><a class="header" href="#the-td-macro">The <code>td!</code> Macro</a></h1>
<p>The <code>td!</code> macro works just like the <code>t!</code> macro but instead of taking the context as it first argument, it takes the desired locale:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>td!(Locale::fr, hello_world)
<span class="boring">}</span></code></pre></pre>
<p>This is useful if for example you want the buttons to switch locale to always be in the language they switch to:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    view! {
        &lt;For
            each = || [Locale::en, Locale::fr]
            key = |locale| *locale
            view = move |locale| view! {
                &lt;button on:click = move|_| i18n.set_locale(locale)&gt;
                    {td!(locale, set_locale)}
                &lt;/button&gt;
            }
        /&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This could just be written has</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::*;
use leptos::*;

#[component]
pub fn Foo() -&gt; impl IntoView {
    let i18n = use_i18n();

    view! {
        &lt;button on:click = move|_| i18n.set_locale(Locale::en)&gt;
            {td!(Locale::en, set_locale)}
        &lt;/button&gt;
        &lt;button on:click = move|_| i18n.set_locale(Locale::fr)&gt;
            {td!(Locale::fr, set_locale)}
        &lt;/button&gt;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>But the above scale better.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-td_string-macro"><a class="header" href="#the-td_string-macro">The <code>td_string!</code> Macro</a></h1>
<p>The <code>td_string!</code> macro is to use interpolations outside the context of rendering views, it let you give a different kind of values and return a <code>Cow&lt;'static, str&gt;</code>.</p>
<p>This requires the <code>interpolate_display</code> feature to be enabled.</p>
<p>It enable you to do this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// click_count = &quot;You clicked {{ count }} times&quot;
assert_eq!(
    td_string!(Locale::en, click_count, count = 10),
    &quot;You clicked 10 times&quot;
)
assert_eq!(
    td_string!(Locale::en, click_count, count = &quot;a lot of&quot;),
    &quot;You clicked a lot of times&quot;
)
<span class="boring">}</span></code></pre></pre>
<h3 id="expected-values"><a class="header" href="#expected-values">Expected values</a></h3>
<p>Variables expect anything that implement <code>Display</code>.</p>
<p>If the key use plurals it expect the type of the count, if you set the type to <code>f32</code>, it expect a <code>f32</code>.</p>
<p>Components expect a value that implement <code>leptos_i18::display::DisplayComponent</code>, you can find some type made to help the formatting in the <code>display</code> module,
such as <code>DisplayComp</code>.</p>
<p><code>String</code> and <code>&amp;str</code> implement this trait such that</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// hello_world = &quot;Hello &lt;b&gt;World&lt;/b&gt; !&quot;

let hw = td_string(Locale::en, hello_world, &lt;b&gt; = &quot;span&quot;);
assert_eq!(hw, &quot;Hello &lt;span&gt;World&lt;/span&gt; !&quot;);
<span class="boring">}</span></code></pre></pre>
<p>The <code>DisplayComp</code> struct let you pass leptos attributes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let attrs = [(&quot;id&quot;, leptos::Attribute::String(&quot;my_id&quot;.into()))];
let b = DisplayComp::new(&quot;div&quot;, &amp;attrs);
let hw = td_string!(Locale::en, hello_world, &lt;b&gt;);
assert_eq!(hw, &quot;Hello &lt;div id=\&quot;my_id\&quot;&gt;World&lt;/div&gt; !&quot;);
<span class="boring">}</span></code></pre></pre>
<p>If you want finer control over the formatting, you can create your own types implementing the <code>DisplayComponent</code> trait, or you can pass this abomination of a function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Fn(&amp;mut core::fmt::Formatter, &amp;dyn Fn(&amp;mut core::fmt::Formatter) -&gt; core::fmt::Result) -&gt; core::fmt::Result
<span class="boring">}</span></code></pre></pre>
<p>which basically let you do this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use core::fmt::{Formatter, Result};

fn render_b(f: &amp;mut Formatter, child: &amp;dyn Fn(&amp;mut Formatter) -&gt; Result) -&gt; Result {
    write!(f, &quot;&lt;div id=\&quot;some_id\&quot;&gt;&quot;)?;
    child(f)?; // format the children
    write!(f, &quot;&lt;/div&gt;&quot;)
}

// hello_world = &quot;Hello &lt;b&gt;World&lt;/b&gt; !&quot;
let hw = td_string!(Locale::en, hello_world, &lt;b&gt; = render_b);
assert_eq!(hw, &quot;Hello &lt;div id=\&quot;some_id\&quot;&gt;World&lt;/div&gt; !&quot;);
<span class="boring">}</span></code></pre></pre>
<p>If you look closely, there is no <code>Clone</code> or <code>'static</code> bounds for any arguments, but they are captured by the value returned by the macro,
so the returned value as a lifetime bound to the &quot;smallest&quot; lifetime of the arguments.</p>
<h1 id="the-td_display-macro"><a class="header" href="#the-td_display-macro">The <code>td_display!</code> Macro</a></h1>
<p>Just like the <code>td_string!</code> macro but return either a struct implementing <code>Display</code> or a <code>&amp;'static str</code> instead of a <code>Cow&lt;'static, str&gt;</code>.</p>
<p>This is usefull if you will print the value or use it in any formatting operation, as it will avoid a temporary <code>String</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::i18n::Locale;
use leptos_i18n::td_display;

// click_count = &quot;You clicked {{ count }} times&quot;
let t = td_display!(Locale::en, click_count, count = 10); // this only return the builder, no work has been done.
assert_eq!(format!(&quot;before {t} after&quot;), &quot;before You clicked 10 times after&quot;);

let t_str = t.to_string(); // can call `to_string` as the value impl `Display`
assert_eq!(t_str, &quot;You clicked 10 times&quot;);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>You can find here all the available features of the crate.</p>
<h4 id="actix"><a class="header" href="#actix"><code>actix</code></a></h4>
<p>This feature must be enabled when building the server with the actix backend</p>
<h4 id="axum"><a class="header" href="#axum"><code>axum</code></a></h4>
<p>This feature must be enabled when building the server with the actix backend</p>
<h4 id="hydrate-1"><a class="header" href="#hydrate-1"><code>hydrate</code></a></h4>
<p>This feature must be enabled when building the client in ssr mode</p>
<h4 id="csr"><a class="header" href="#csr"><code>csr</code></a></h4>
<p>This feature must be enabled when building the client in csr mode</p>
<h4 id="serde"><a class="header" href="#serde"><code>serde</code></a></h4>
<p>This feature implement <code>Serialize</code> and <code>Deserialize</code> for the <code>Locale</code> enum</p>
<h4 id="debug_interpolations"><a class="header" href="#debug_interpolations"><code>debug_interpolations</code></a></h4>
<p>This features allow the <code>load_locales!</code> macro to generate more code for interpolations, allowing better error reporting when keys are missing.</p>
<h4 id="suppress_key_warnings"><a class="header" href="#suppress_key_warnings"><code>suppress_key_warnings</code></a></h4>
<p>This features disable the warnings when a key is missing or in surplus, we discourage its usage and highly encourage the use of explicit defaults, but if its what's you want, we won't stop you.</p>
<h4 id="json_files-default"><a class="header" href="#json_files-default"><code>json_files</code> (Default)</a></h4>
<p>To enable when you use JSON files for your locales</p>
<h4 id="yaml_files"><a class="header" href="#yaml_files"><code>yaml_files</code></a></h4>
<p>To enable when you use YAML files for your locales</p>
<h4 id="cookie-default"><a class="header" href="#cookie-default"><code>cookie</code> (Default)</a></h4>
<p>Set a cookie to remember the last chosen locale.</p>
<h4 id="nightly"><a class="header" href="#nightly"><code>nightly</code></a></h4>
<ul>
<li>Enable the use of some nighly features, like directly calling the context to get/set the current locale.</li>
<li>Allow the <code>load_locale!</code> macro to emit better warnings.</li>
</ul>
<h4 id="track_locale_files"><a class="header" href="#track_locale_files"><code>track_locale_files</code></a></h4>
<p>Allow tracking of locale files as dependencies for rebuilds in stable.
The <code>load_locales!()</code> macro using external dependencies the build system is not aware that the macro should be rerun when those files changes,
you may have noticed that if you use <code>cargo-leptos</code> with <code>watch-additional-files = [&quot;locales&quot;]</code> and running <code>cargo leptos watch</code>, even if the file changes and cargo-leptos triggers a rebuild nothing changes.
This feature use a &quot;trick&quot; by using <code>include_bytes!()</code> to declare the use of a file, but I'm a bit sceptical of the impact on build time using this.
I've already checked and it does not include the bytes in the final binary, even in debug, but it may slow down compilation time.
If you use the <code>nighly</code> feature it use the <a href="https://github.com/rust-lang/rust/issues/99515">path tracking API</a> so no trick using <code>include_bytes!</code> and the possible slowdown in compile times coming with it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-i18n-ally-vs-code-extension"><a class="header" href="#the-i18n-ally-vs-code-extension">The <code>i18n Ally</code> VS Code extension</a></h1>
<p>The <a href="https://marketplace.visualstudio.com/items?itemName=lokalise.i18n-ally"><code>i18n Ally</code></a> extension is an extension
that have a bunch of features for managing, structuring and even automate translations, with the most notable one being an overlay over translations keys
in the code displaying the corresponding translations.</p>
<p>This is very helpfull, and this section is a guide for a minimal setup to make this extension work with <code>Leptos i18n</code>.</p>
<h2 id="custom-framework-setup"><a class="header" href="#custom-framework-setup">Custom framework setup</a></h2>
<p>For obvious reason this lib is not supported by <code>i18n Ally</code> (one day maybe ?), but the awesome people working on that extension
gave us <a href="https://github.com/lokalise/i18n-ally/wiki/Custom-Framework">a way</a> to make it work with custom frameworks.</p>
<p>You will need to first create a file in your <code>.vscode</code> folder named <code>i18n-ally-custom-framework.yml</code> and put this in it:</p>
<pre><code class="language-yaml">languageIds:
  - rust

usageMatchRegex:
  - &quot;[^\\w\\d]t!\\(\\s*[\\w.:]*,\\s*([\\w.]*)&quot;
  - &quot;[^\\w\\d]td!\\(\\s*[\\w.:]*,\\s*([\\w.]*)&quot;
  - &quot;[^\\w\\d]td_string!\\(\\s*[\\w.:]*,\\s*([\\w.]*)&quot;
  - &quot;[^\\w\\d]td_display!\\(\\s*[\\w.:]*,\\s*([\\w.]*)&quot;

monopoly: true
</code></pre>
<p><code>languageIds</code> is the language you are using in your project, I'm no expert but this is probably for a VSC api to know what files to check.</p>
<p><code>usageMatchRegex</code> is the regex to use to find the translations keys, the above regex are for, in order, <code>t!</code>, <code>td!</code>, <code>td_string!</code> and <code>td_display!</code>. If you don't use all translations macro you can remove/comment out the regex for that macro. Those regex are not perfect, and I'm no expert so there maybe is some better/faster ones, and if you encounter a problem with them feel free to open an issue/discussion on github about it.</p>
<p><code>monopoly</code> is to disable all supported frameworks, if you use any other frameworks supported by the extension in your project set it to <code>false</code>.</p>
<h2 id="common-settings"><a class="header" href="#common-settings">Common settings</a></h2>
<p>There is multiple settings for the extension that you can set in <code>.vscode/settings.json</code>, those are all optionnal, here is non exhaustive list with their (default):</p>
<ul>
<li>
<p><code>i18n-ally.keystyle</code> (auto): this one can be <code>flat</code> (<code>&quot;a.b.c&quot;: &quot;...&quot;</code>) or <code>nested</code> (<code>&quot;a&quot;: { &quot;b&quot;: { &quot;c&quot;: &quot;...&quot; } }</code>), this is irrelevant to you if you don't use subkeys, but if you do, set it to <code>&quot;nested&quot;</code> as this is the style that this lib support.</p>
</li>
<li>
<p><code>i18n-ally.localesPaths</code> (auto): this is the path to your locales, it can be a path or a list of path, by default set it to <code>&quot;locales&quot;</code>, but if you either have a custom locales path or use a cargo workspaces you will have to supply the path here.</p>
</li>
<li>
<p><code>i18n-ally.namespace</code> (false): this is is if you use namespaces, set it to <code>true</code> then. If you use namespaces with <code>i18n Ally</code> I have not figured out (maybe you will ?) how to make the <code>namespace::key</code> syntax work for the macros, so just use <code>namespace.key</code>.</p>
</li>
<li>
<p><code>i18n-ally.sourceLanguage</code> (en): The primary key of the project, so I suggest putting the default locale for the value.</p>
</li>
<li>
<p><code>i18n-ally.displayLanguage</code> (en): The locale that the overlay use.</p>
</li>
</ul>
<p>You can find other settings that could interest you in the <a href="https://github.com/lokalise/i18n-ally/wiki/Configurations">official doc</a>, with more informations about the settings mentionned above, with their default value.</p>
<h2 id="other-features"><a class="header" href="#other-features">Other features</a></h2>
<p>This extension offer some other interesting features that could interest you, I would suggest you to take a look at their <a href="https://github.com/lokalise/i18n-ally/wiki">wiki</a> for mor informations.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
